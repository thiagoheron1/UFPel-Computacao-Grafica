<!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - OBJLoader + MTLLoader</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>


  <script type="module">

    import * as THREE from './three.js-master/build/three.module.js';

    import { DDSLoader } from './three.js-master/examples/jsm/loaders/DDSLoader.js';
    import { MTLLoader } from './three.js-master/examples/jsm/loaders/MTLLoader.js';
    import { OBJLoader } from './three.js-master/examples/jsm/loaders/OBJLoader.js';
    import { GLTFLoader } from './three.js-master/examples/jsm/loaders/GLTFLoader.js';
    import { TextureLoader } from './three.js-master/src/loaders/TextureLoader.js';

    var container;
    var camera, scene, renderer;
    var mouseX = 0, mouseY = 0;
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    init();
    animate();

    function init() {

      container = document.createElement('div');
      document.body.appendChild(container);

      // Scene
      scene = new THREE.Scene();
      var ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
      scene.add(ambientLight);

      // Camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
      var pointLight = new THREE.PointLight(0xffffff, 0.8);
      camera.add(pointLight);
      camera.position.x = 0;
      camera.position.y = 50;
      camera.position.z = 150;
      camera.lookAt(scene.position);
      scene.add(camera);

      // Grid Helper
      var gridHelper = new THREE.GridHelper(100, 20);
      gridHelper.position.x = 0;
      gridHelper.position.y = 0;
      scene.add(gridHelper);


      var onProgress = function (xhr) {
        if (xhr.lengthComputable) {
          var percentComplete = xhr.loaded / xhr.total * 100;
          console.log(Math.round(percentComplete, 2) + '% downloaded');
        }
      };
      var onError = function () { };
      var manager = new THREE.LoadingManager();
      manager.addHandler(/\.dds$/i, new DDSLoader());

      /*
      let materialLoader = new MTLLoader(manager)
        .setPath('models/objects/a-gaming-laptop/source/')
        .load('Laptop.mtl', function (materials) {

          materials.preload();

          new OBJLoader(manager)
            .setMaterials(materials)
            .setPath('models/objects/a-gaming-laptop/source/')
            .load('Laptop.obj', function (object) {

              THREE.Object3D.DefaultUp.set(0.0, 0.0, 1.0);


              object.position.y = 0;
              object.scale.x = 5;
              object.scale.y = 5;
              object.scale.z = 5;

              scene.add(object);

            }, onProgress, onError);

        });
      */
      var loader = new GLTFLoader();

      loader.load('models/objects/low_poly_gaming_setup/scene.gltf', handle_load);

      var mesh;

      function handle_load(gltf) {

          console.log(gltf);
          mesh = gltf.scene;
          console.log(mesh.children[0]);
          mesh.children[0].material = new THREE.MeshLambertMaterial();
      scene.add( mesh );
          mesh.position.z = -10;
      }





      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {

      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function animate() {

      requestAnimationFrame(animate);
      render();

    }

    function render() {

      renderer.render(scene, camera);

    }












    /*


          function init() {



            function loadModel() {

              object.traverse( function ( child ) {

                if ( child.isMesh ) child.material.map = texture;

              } );

              object.position.y = - 95;
              scene.add( object );

            }

            var manager = new THREE.LoadingManager( loadModel );

            manager.onProgress = function ( item, loaded, total ) {

              console.log( item, loaded, total );

            };

            // texture

            var textureLoader = new THREE.TextureLoader( manager );

            var texture = textureLoader.load( 'textures/uv_grid_opengl.jpg' );

            // model

            function onProgress( xhr ) {

              if ( xhr.lengthComputable ) {

                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log( 'model ' + Math.round( percentComplete, 2 ) + '% downloaded' );

              }

            }

            function onError() {}

            var loader = new OBJLoader( manager );

            loader.load( './models/obj/herkules/source/Herkules_Kalliope_C.obj', function ( obj ) {

              object = obj;

            }, onProgress, onError );

            //

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );

            document.addEventListener( 'mousemove', onDocumentMouseMove, false );

            //

            window.addEventListener( 'resize', onWindowResize, false );

          }

          function onWindowResize() {

            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

          }

          function onDocumentMouseMove( event ) {

            mouseX = ( event.clientX - windowHalfX ) / 2;
            mouseY = ( event.clientY - windowHalfY ) / 2;

          }

          //

          function animate() {

            requestAnimationFrame( animate );
            render();

          }

          function render() {

            camera.position.x += ( mouseX - camera.position.x ) * .05;
            camera.position.y += ( - mouseY - camera.position.y ) * .05;

            camera.lookAt( scene.position );

            renderer.render( scene, camera );

          }
    */
  </script>

</body>

</html>